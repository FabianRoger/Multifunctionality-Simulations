---
title: "sensibility of multithreshold approach"
output: html_notebook
---

```{r, echo = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(cowplot)
library(RColorBrewer)

source("functions_short.R")
```

```{r}
# choose model (by setting vlaue to TRUE)

Single_dist <- FALSE
Multi_dist <- FALSE
Biodepth_data <- TRUE

if(sum(Single_dist,Multi_dist,Biodepth_data) != 1){stop("please choose one (and only one) scenario by setting the value to TRUE")}

```

```{r}

if(Single_dist) {
  
set.seed(999)

specnum <- 15
funcnum <- 9

distribution = "rnorm" #choose your distribution (one off ?Distributions)

FuncMat <- FunctionValue(specnum,funcnum, distribution, mean = 30, sd = 2)  
func.names <- as.character( unique( FuncMat$Functions))

spec.names <- as.character( unique( FuncMat$Species))

SpecMat <- SpeciesMatrix(specnum = specnum, maxrep = 200)

method = "av"

AvFunc <- AverageFunction(SpecMat, FuncMat,
                          method = method, 
                          CF = CF, 
                          compfunc = compfunc,
                          r = r)

}
  
```

```{r}

if(Multi_dist) {
  
set.seed(999)

specnum <- 15
funcnum <- 9

distribution = "rnorm" #choose your distribution (one off ?Distributions)


# if function values should be drawn form distributiuon with differnt means

FuncList <- list()

par1 <- seq(50, 100, len = funcnum) #parameter values for functions 1:nfunc (first parameter)
par2 <- seq(15,3, len = funcnum) #parameter values for functions 1:nfunc (second parameter - if needed)

for (i in 1:funcnum){
var <- paste("FuncMat", i, sep = "_")

# you have to name the parameters according to your chosen distribution
FuncList[[var]] <- FunctionValue(specnum,funcnum, distribution, mean = par1[[i]], sd = par2[[i]])  
}

FuncMat <- FuncList[[1]]

func.names <- as.character( unique( FuncMat$Functions))

for(n in seq_along(func.names)){
  FuncMat[FuncMat$Functions == func.names[n], ]$Funcval <- FuncList[[n]][FuncList[[n]]$Functions == func.names[n], ]$Funcval
}

spec.names <- as.character( unique( FuncMat$Species))

SpecMat <- SpeciesMatrix(specnum = specnum, maxrep = 200)

method = "av"

AvFunc <- AverageFunction(SpecMat, FuncMat,
                          method = method, 
                          CF = CF, 
                          compfunc = compfunc,
                          r = r)
}
```




```{r}

if(Biodepth_data) {

data("all_biodepth")
  
#choose Location
  # (one off "Germany" "Portugal" "Switzerland" "Greece" "Ireland" "Sweden" "Sheffield" "Silwood" )
  
  Location <- "Portugal"

biodepth_func <- 
  all_biodepth %>% 
  gather("species", "p_a", 26:ncol(.)) %>% 
  filter(p_a == 1) %>% 
  filter(Diversity == 1) %>% 
  filter(location == Location) %>% 
  select(species, 15:25) %>% 
  select_if(function(col) sum(is.na(col)) <= floor(0.2*length(col))) %>% #exclude functions with > 20% NAs
  na.omit() %>% #exclude species with missing functio values
  group_by(species) %>% 
  summarise_all(function(x) mean(x, na.rm = T)) %>% 
  rename("Species" = species)

specnum <- nrow(biodepth_func)
spec.names <- biodepth_func$Species


funcnum <- ncol(biodepth_func)-1


FuncMat <- gather(biodepth_func, Functions, Funcval, -Species)
func.names <- as.character( unique( FuncMat$Functions))

SpecMat <- SpeciesMatrix(specnum, maxrep = 500)
dimnames(SpecMat)[[2]] <- spec.names

method = "av"

AvFunc <- AverageFunction(SpecMat, FuncMat,
                          method = method, 
                          CF = CF, 
                          compfunc = compfunc,
                          r = r)

}

```


```{r}

# standardize functions by maximum
AvFunc_max <- AvFunc %>% 
  mutate_at(vars(one_of(func.names)), function(x) {x / max(x)})

# standardize functions between 0 and 1
AvFunc_unit <- AvFunc %>% 
   mutate_at(vars(one_of(func.names)), function(x) {(x - min(x)) / (max(x) - min(x))})

Av_list <- list(AvFunc_max = AvFunc_max,
                AvFunc_unit = AvFunc_unit)

RES_stand <- data.frame(thresholds = numeric(), 
                   Estimate = numeric(),
                   `Std. Error` = numeric(), 
                   stand_method = character())


for (i in seq_along(Av_list)) { #loop over all subsets of function of size 1:funcnum
  
  mixedThresh <- getFuncsMaxed(Av_list[[i]], func.names, threshmin=0.05, threshmax=0.99, prepend=c("Richness"), maxN=1)
   
  # if maximum funcitoninh should be calculated instead
  
  #mixedThresh <- mixedThresh %>% 
  #  group_by(Richness, thresholds, thresh) %>% 
  #  summarize(funcMaxed = max(funcMaxed)) %>% ungroup
  
  mixedLinearSlopes<-getCoefTab(funcMaxed ~ Richness, fun = lm,  data=mixedThresh, 
                               coefVar="Richness")
    
  colnames(mixedLinearSlopes) <- c("thresholds", "Estimate",  "Std. Error", "t value", "Pr(>|t|)")
    
  temp <- mixedLinearSlopes %>% 
      select(thresholds, Estimate, `Std. Error`) %>% 
      mutate(stand_method = names(Av_list)[i])
    
    RES_stand <- rbind(RES_stand, temp)
  }

```


```{r}

STAND <- RES_stand %>% 
  group_by(thresholds, stand_method) %>% 
  mutate(CI_high = Estimate + 1.96 * `Std. Error`,
            CI_low = Estimate - 1.96 * `Std. Error`) %>% 
ggplot(., aes(x=thresholds*100, y=Estimate), size = 0.5, alpha = 0.3)+
  geom_ribbon(aes(ymin = CI_low, ymax = CI_high, fill = as.factor(stand_method)), colour = NA, alpha = 0.4)+
  geom_line( aes(colour = as.factor(stand_method)), lwd = 0.8) +
  ylab("Slope estimate") + xlab("Threshold (%)") +
  geom_abline(intercept=0, slope=0, lwd=0.5, linetype=2) + 
  theme_bw(base_size=15)+
  scale_fill_brewer(guide = FALSE, palette = "Set1")+
  scale_color_brewer(guide = guide_legend(title =""), palette = "Set1", labels = c("scaled by max", "scaled [0,1]"))+
  theme_classic()+
  theme(legend.position = c(.2,0.3))
  
  
STAND
```



```{r}

get_colours <- colorRampPalette(brewer.pal(9, "Greys"))

Hist_orig <- AvFunc %>% 
  select(one_of(func.names)) %>% 
  gather(Func, value) %>% 
  ggplot(.)+
  geom_density(aes(x = value,y =..density.., colour = Func), position="identity")+
  scale_colour_manual( values = get_colours(funcnum))+
  theme_classic()+
  theme(legend.position = "none") +
  labs(x = "Simulated function values", y = "Density")

Hist_orig

```


```{r}

Hist_unit <- AvFunc_unit %>% 
  select(one_of(func.names)) %>% 
  gather(Func, value) 


  maxD <- Hist_unit %>% 
  group_by(Func) %>% 
  summarize(maxD = max(density(value)$y)) %>% 
  ungroup %>% 
  summarize(maxD = max(maxD)) %>% as.numeric()

get_colours <- colorRampPalette(brewer.pal(9, "Blues"))
    
Hist_unit_gg <- ggplot(Hist_unit)+
  geom_density(aes(x = value,y =..density.., colour = Func), position="identity")+
  geom_vline(aes(xintercept = mean(value)), colour = "black", linetype = "dashed")+
  annotate("label", x = 0.2, y = 0.8*maxD,
           label = "f(x) == frac(x - plain(min)(x), plain(max)(x) - plain(min)(x))", 
           parse=T, size = 2.5, alpha = 0.8)+
  geom_vline(aes(xintercept = mean(value)), colour = "black", linetype = "dashed")+
  scale_colour_manual(values = get_colours(funcnum))+
  theme_classic()+
  theme(legend.position = "none")+
  labs(x = "Scaled between [0,1]", y = "Density")

Hist_unit_gg

```


```{r}

Hist_max <- AvFunc_max %>% 
  select(one_of(func.names)) %>% 
  gather(Func, value) 

maxD <- Hist_max %>% 
  group_by(Func) %>% 
  summarize(maxD = max(density(value)$y)) %>% 
  ungroup %>% 
  summarize(maxD = max(maxD)) %>% as.numeric()

get_colours <- colorRampPalette(brewer.pal(9, "Reds"))
  
Hist_max_gg <- ggplot(Hist_max)+
  geom_density(aes(x = value,y =..density.., colour = Func), position="identity")+
  geom_vline(aes(xintercept = mean(value)), colour = "black", linetype = "dashed")+
  annotate("label", x = 0.4, y = 0.8*maxD, 
           label = "f(x) == frac(x , plain(max)(x))", 
           parse=T, size = 2.5)+
  scale_colour_manual(values = get_colours(funcnum))+
  scale_x_continuous(limits = c(0,1))+
  theme_classic()+
  theme(legend.position = "none")+
  labs(x = "Scaled by maximum", y = "Density")

Hist_max_gg
```


```{r}

ggdraw() +
  draw_plot(STAND, 0, .5, 1, .5) +
  draw_plot(Hist_orig, 0, 0, 1/3, 0.5) +
  draw_plot(Hist_unit_gg, 1/3, 0, 1/3, 0.5)+
  draw_plot(Hist_max_gg, 2/3, 0, 1/3, 0.5)
```

